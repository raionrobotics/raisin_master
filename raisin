#!/usr/bin/env bash
set -euo pipefail

# RAISIN wrapper script for easier command-line usage.
# Intended to be symlinked into your PATH as `raisin`.

# Resolve symlinks so this works when `raisin` is symlinked into PATH.
SOURCE="${BASH_SOURCE[0]}"
while [[ -h "$SOURCE" ]]; do
  DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
  SOURCE="$(readlink "$SOURCE")"
  [[ "$SOURCE" != /* ]] && SOURCE="${DIR}/${SOURCE}"
done
DEFAULT_SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"

# Prefer the RAISIN repo that contains the current working directory (useful when
# multiple copies of this repo exist). We detect a repo root by the presence of
# `raisin.py` and the `commands/` package.
SCRIPT_DIR="${DEFAULT_SCRIPT_DIR}"
search_dir="${PWD}"
while [[ -n "${search_dir}" && "${search_dir}" != "/" ]]; do
  if [[ -f "${search_dir}/raisin.py" && -d "${search_dir}/commands" ]]; then
    SCRIPT_DIR="${search_dir}"
    break
  fi
  search_dir="$(dirname "${search_dir}")"
done

if [[ "${1:-}" == "--install" ]]; then
  raisin_extract_env_name() {
    local target="$1"
    local name=""

    if [[ ! -f "${target}" ]]; then
      return 1
    fi

    name="$(awk -F= '/^DEFAULT_ENV_NAME=/{gsub(/^[^"]*"/, "", $0); gsub(/"$/, "", $0); print; exit}' "${target}")"
    if [[ -n "${name}" ]]; then
      printf '%s\n' "${name}"
      return 0
    fi
    return 1
  }

  raisin_valid_env_name() {
    local name="$1"

    if [[ -z "${name}" ]]; then
      return 1
    fi
    if [[ "${name}" =~ [[:space:]] ]]; then
      return 1
    fi
    if [[ "${name}" == *"/"* ]]; then
      return 1
    fi
    if [[ ! "${name}" =~ ^[A-Za-z0-9._-]+$ ]]; then
      return 1
    fi
    return 0
  }

  raisin_update_env_name() {
    local target="$1"
    local env_name="$2"
    local tmp=""

    tmp="$(mktemp)"
    if ! awk -v env_name="${env_name}" '
      BEGIN {updated=0}
      /^DEFAULT_ENV_NAME=/ { print "DEFAULT_ENV_NAME=\"" env_name "\""; updated=1; next }
      { print }
      END { if (!updated) exit 2 }
    ' "${target}" > "${tmp}"; then
      rm -f "${tmp}"
      return 1
    fi

    if ! mv "${tmp}" "${target}"; then
      rm -f "${tmp}"
      return 1
    fi
  }

  target_dir="${HOME}/.local/bin"
  mkdir -p "$target_dir"
  install_path="${target_dir}/raisin"
  # Install a copy (not a symlink) so it keeps working even if the repo is moved.
  src_path="${SCRIPT_DIR}/raisin"
  if [[ ! -f "${src_path}" ]]; then
    src_path="${DEFAULT_SCRIPT_DIR}/raisin"
  fi

  install_env_name_default="raisin_master"
  if install_env_name_existing="$(raisin_extract_env_name "${install_path}" 2>/dev/null)"; then
    install_env_name_default="${install_env_name_existing}"
  fi

  install_env_home="${HOME}/.venvs"
  install_env_name="${install_env_name_default}"
  if [[ -t 0 && -t 1 ]]; then
    install_env_path_default="${install_env_home}/${install_env_name_default}"
    read -r -p "Python ðŸ environment name [${install_env_name_default}] (path: ${install_env_path_default}): " install_env_name
    install_env_name="${install_env_name:-${install_env_name_default}}"
  fi

  if ! raisin_valid_env_name "${install_env_name}"; then
    echo "âŒ Error: invalid environment name: ${install_env_name}" >&2
    echo "Use only letters, numbers, dots, dashes, and underscores." >&2
    exit 1
  fi
  install_env_path="${install_env_home}/${install_env_name}"
  echo "Environment path: ${install_env_path}"

  if ! rm -f "${install_path}"; then
    echo "âŒ Error: cannot overwrite ${install_path}. Check permissions/ownership." >&2
    exit 1
  fi
  if ! cp -f "${src_path}" "${install_path}"; then
    echo "âŒ Error: failed to install wrapper to ${install_path}." >&2
    exit 1
  fi

  if ! raisin_update_env_name "${install_path}" "${install_env_name}"; then
    echo "âŒ Error: failed to update environment name in ${install_path}." >&2
    exit 1
  fi

  chmod +x "${install_path}"
  echo "Installed: ${install_path}"
  echo "Environment name: ${install_env_name}"
  echo "If needed, add to PATH: export PATH=\"${HOME}/.local/bin:\$PATH\""
  exit 0
fi

if [[ "${1:-}" == "--where" || "${1:-}" == "--which" ]]; then
  echo "raisin wrapper: ${DEFAULT_SCRIPT_DIR}/raisin"
  echo "selected repo:  ${SCRIPT_DIR}"
  echo "raisin.py:      ${SCRIPT_DIR}/raisin.py"
  echo "config:         ${SCRIPT_DIR}/configuration_setting.yaml"
  exit 0
fi

DEFAULT_ENV_NAME="raisin_master"
DEFAULT_ENV_HOME="${HOME}/.venvs"
DEFAULT_ENV_DIR="${DEFAULT_ENV_HOME}/${DEFAULT_ENV_NAME}"

raisin_resolve_python() {
  local target="${1:-}"

  if [[ -z "${target}" ]]; then
    return 1
  fi

  if [[ -d "${target}" ]]; then
    if [[ -x "${target}/bin/python" ]]; then
      printf '%s\n' "${target}/bin/python"
      return 0
    elif [[ -x "${target}/bin/python3" ]]; then
      printf '%s\n' "${target}/bin/python3"
      return 0
    fi
  fi

  if [[ -x "${target}" ]]; then
    printf '%s\n' "${target}"
    return 0
  fi

  if [[ -x "${target}/bin/python" ]]; then
    printf '%s\n' "${target}/bin/python"
    return 0
  fi
  if [[ -x "${target}/bin/python3" ]]; then
    printf '%s\n' "${target}/bin/python3"
    return 0
  fi

  return 1
}

raisin_find_bootstrap_python() {
  local py_bin=""

  py_bin="$(command -v python3 || true)"
  if [[ -n "${py_bin}" ]]; then
    printf '%s\n' "${py_bin}"
    return 0
  fi

  py_bin="$(command -v python || true)"
  if [[ -n "${py_bin}" ]]; then
    printf '%s\n' "${py_bin}"
    return 0
  fi

  return 1
}

raisin_ensure_virtualenv() {
  local bootstrap_python="$1"

  if "${bootstrap_python}" -m virtualenv --version >/dev/null 2>&1; then
    return 0
  fi

  if ! "${bootstrap_python}" -m pip --version >/dev/null 2>&1; then
    echo "âŒ Error: pip is not available for ${bootstrap_python}." >&2
    echo "Install pip to create the RAISIN environment." >&2
    return 1
  fi

  echo "Installing virtualenv with ${bootstrap_python}..."
  if "${bootstrap_python}" -m pip install virtualenv; then
    return 0
  fi

  if [[ "$(id -u)" -ne 0 ]]; then
    if "${bootstrap_python}" -m pip install --user virtualenv; then
      return 0
    fi
  else
    if "${bootstrap_python}" -m pip install --break-system-packages virtualenv; then
      return 0
    fi
  fi

  return 1
}

raisin_create_env() {
  local env_dir="$1"
  local bootstrap_python=""
  local env_python=""

  bootstrap_python="$(raisin_find_bootstrap_python || true)"
  if [[ -z "${bootstrap_python}" ]]; then
    echo "âŒ Error: python3 not found. Install Python 3 or set RAISIN_PYTHON." >&2
    exit 1
  fi

  mkdir -p "$(dirname "${env_dir}")"

  if [[ ! -x "${env_dir}/bin/python" && ! -x "${env_dir}/bin/python3" ]]; then
    if ! raisin_ensure_virtualenv "${bootstrap_python}"; then
      echo "âŒ Error: failed to install virtualenv." >&2
      exit 1
    fi
    echo "Creating RAISIN environment at ${env_dir}..."
    "${bootstrap_python}" -m virtualenv "${env_dir}"
  fi

  if ! env_python="$(raisin_resolve_python "${env_dir}")"; then
    echo "âŒ Error: failed to find python in ${env_dir}." >&2
    exit 1
  fi

  if [[ -f "${SCRIPT_DIR}/requirements.txt" ]]; then
    echo "Installing RAISIN requirements..."
    "${env_python}" -m pip install --upgrade pip
    "${env_python}" -m pip install -r "${SCRIPT_DIR}/requirements.txt"
  fi
}

raisin_prompt_for_python() {
  local choice=""
  local env_input=""
  local resolved=""
  local default_choice="1"

  if [[ -t 0 && -t 1 ]]; then
    echo "No RAISIN Python environment found."
    echo "1) Create default environment (${DEFAULT_ENV_DIR})"
    echo "2) Use existing environment"
    echo "3) Use system Python"
    read -r -p "Select [${default_choice}]: " choice
  else
    choice="${default_choice}"
  fi

  case "${choice:-${default_choice}}" in
    1|"")
      raisin_create_env "${DEFAULT_ENV_DIR}"
      raisin_resolve_python "${DEFAULT_ENV_DIR}"
      return 0
      ;;
    2)
      if [[ ! -t 0 || ! -t 1 ]]; then
        echo "âŒ Error: no TTY available to select an existing environment." >&2
        return 1
      fi
      while true; do
        read -r -p "Path to existing venv dir or python executable: " env_input
        if resolved="$(raisin_resolve_python "${env_input}")"; then
          printf '%s\n' "${resolved}"
          return 0
        fi
        echo "âŒ Not a valid environment or python: ${env_input}" >&2
      done
      ;;
    3)
      resolved="$(raisin_find_bootstrap_python || true)"
      if [[ -z "${resolved}" ]]; then
        echo "âŒ Error: python3 not found. Install Python 3 or set RAISIN_PYTHON." >&2
        return 1
      fi
      printf '%s\n' "${resolved}"
      return 0
      ;;
    *)
      echo "âŒ Invalid choice: ${choice}" >&2
      return 1
      ;;
  esac
}

python_bin="${RAISIN_PYTHON:-}"
if [[ -n "${python_bin}" ]]; then
  if [[ ! -x "${python_bin}" ]]; then
    echo "âŒ Error: RAISIN_PYTHON is not executable: ${python_bin}" >&2
    exit 1
  fi
else
  if python_bin="$(raisin_resolve_python "${DEFAULT_ENV_DIR}")"; then
    :
  elif python_bin="$(raisin_resolve_python "${SCRIPT_DIR}/.venv")"; then
    :
  elif python_bin="$(raisin_resolve_python "${SCRIPT_DIR}/venv")"; then
    :
  else
    if ! python_bin="$(raisin_prompt_for_python)"; then
      exit 1
    fi
  fi
fi

if [[ -z "${python_bin}" ]]; then
  echo "âŒ Error: python3 not found. Install Python 3 or set RAISIN_PYTHON." >&2
  exit 1
fi

exec "${python_bin}" "${SCRIPT_DIR}/raisin.py" "$@"
