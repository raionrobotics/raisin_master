#!/usr/bin/env bash
set -euo pipefail

# RAISIN wrapper script for easier command-line usage.
# Intended to be symlinked into your PATH as `raisin`.

# Resolve symlinks so this works when `raisin` is symlinked into PATH.
SOURCE="${BASH_SOURCE[0]}"
while [[ -h "$SOURCE" ]]; do
  DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
  SOURCE="$(readlink "$SOURCE")"
  [[ "$SOURCE" != /* ]] && SOURCE="${DIR}/${SOURCE}"
done
DEFAULT_SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"

# Prefer the RAISIN repo that contains the current working directory (useful when
# multiple copies of this repo exist). We detect a repo root by the presence of
# `raisin.py` and the `commands/` package.
SCRIPT_DIR="${DEFAULT_SCRIPT_DIR}"
search_dir="${PWD}"
while [[ -n "${search_dir}" && "${search_dir}" != "/" ]]; do
  if [[ -f "${search_dir}/raisin.py" && -d "${search_dir}/commands" ]]; then
    SCRIPT_DIR="${search_dir}"
    break
  fi
  search_dir="$(dirname "${search_dir}")"
done

# ============================================================================
# Helper functions (defined early so --install can reuse them)
# ============================================================================

raisin_find_bootstrap_python() {
  local py_bin=""

  py_bin="$(command -v python3 || true)"
  if [[ -n "${py_bin}" ]]; then
    printf '%s\n' "${py_bin}"
    return 0
  fi

  py_bin="$(command -v python || true)"
  if [[ -n "${py_bin}" ]]; then
    printf '%s\n' "${py_bin}"
    return 0
  fi

  return 1
}

raisin_ensure_virtualenv() {
  local bootstrap_python="$1"

  if "${bootstrap_python}" -m virtualenv --version >/dev/null 2>&1; then
    return 0
  fi

  if ! "${bootstrap_python}" -m pip --version >/dev/null 2>&1; then
    echo "âŒ Error: pip is not available for ${bootstrap_python}." >&2
    echo "Install pip to create the RAISIN environment." >&2
    return 1
  fi

  echo "Installing virtualenv with ${bootstrap_python}..."
  if "${bootstrap_python}" -m pip install virtualenv; then
    return 0
  fi

  if [[ "$(id -u)" -ne 0 ]]; then
    if "${bootstrap_python}" -m pip install --user virtualenv; then
      return 0
    fi
  else
    if "${bootstrap_python}" -m pip install --break-system-packages virtualenv; then
      return 0
    fi
  fi

  return 1
}

raisin_create_env() {
  local env_dir="$1"
  local bootstrap_python=""
  local env_python=""

  bootstrap_python="$(raisin_find_bootstrap_python || true)"
  if [[ -z "${bootstrap_python}" ]]; then
    echo "âŒ Error: python3 not found. Install Python 3 or set RAISIN_PYTHON." >&2
    return 1
  fi

  mkdir -p "$(dirname "${env_dir}")"

  if ! raisin_resolve_python "${env_dir}" > /dev/null 2>&1; then
    if ! raisin_ensure_virtualenv "${bootstrap_python}"; then
      echo "âŒ Error: failed to install virtualenv." >&2
      return 1
    fi
    echo "Creating RAISIN environment at ${env_dir}..."
    "${bootstrap_python}" -m virtualenv "${env_dir}"
  fi

  if ! env_python="$(raisin_resolve_python "${env_dir}")"; then
    echo "âŒ Error: failed to find python in ${env_dir}." >&2
    return 1
  fi

  if [[ -f "${SCRIPT_DIR}/requirements.txt" ]]; then
    echo "Installing RAISIN requirements..."
    "${env_python}" -m pip install --upgrade pip
    "${env_python}" -m pip install -r "${SCRIPT_DIR}/requirements.txt"
  fi
}

raisin_resolve_python() {
  local target="${1:-}"

  if [[ -z "${target}" ]]; then
    return 1
  fi

  if [[ -d "${target}" ]]; then
    if [[ -x "${target}/bin/python" ]]; then
      printf '%s\n' "${target}/bin/python"
      return 0
    elif [[ -x "${target}/bin/python3" ]]; then
      printf '%s\n' "${target}/bin/python3"
      return 0
    elif [[ "$(uname -s)" =~ ^(CYGWIN|MINGW|MSYS) && -x "${target}/Scripts/python.exe" ]]; then
      printf '%s\n' "${target}/Scripts/python.exe"
      return 0
    fi
  fi

  if [[ -x "${target}" ]]; then
    printf '%s\n' "${target}"
    return 0
  fi

  return 1
}

# ============================================================================
# --install handler
# ============================================================================

if [[ "${1:-}" == "--install" ]]; then
  raisin_extract_env_name() {
    local target="$1"
    local name=""

    if [[ ! -f "${target}" ]]; then
      return 1
    fi

    name="$(awk -F'"' '/^DEFAULT_ENV_NAME=/{print $2; exit}' "${target}")"
    if [[ -n "${name}" ]]; then
      printf '%s\n' "${name}"
      return 0
    fi
    return 1
  }

  raisin_valid_env_name() {
    local name="$1"

    if [[ -z "${name}" ]]; then
      return 1
    fi
    if [[ "${name}" =~ [[:space:]] ]]; then
      return 1
    fi
    if [[ "${name}" == *"/"* ]]; then
      return 1
    fi
    if [[ ! "${name}" =~ ^[A-Za-z0-9._-]+$ ]]; then
      return 1
    fi
    return 0
  }

  raisin_update_env_name() {
    local target="$1"
    local env_name="$2"
    local tmp=""

    tmp="$(mktemp)"
    if ! awk -v env_name="${env_name}" '
      BEGIN {updated=0}
      /^DEFAULT_ENV_NAME=/ { print "DEFAULT_ENV_NAME=\"" env_name "\""; updated=1; next }
      { print }
      END { if (!updated) exit 2 }
    ' "${target}" > "${tmp}"; then
      rm -f "${tmp}"
      return 1
    fi

    if ! mv "${tmp}" "${target}"; then
      rm -f "${tmp}"
      return 1
    fi
  }

  target_dir="${HOME}/.local/bin"
  mkdir -p "$target_dir"
  install_path="${target_dir}/raisin"
  # Install a copy (not a symlink) so it keeps working even if the repo is moved.
  src_path="${SCRIPT_DIR}/raisin"
  if [[ ! -f "${src_path}" ]]; then
    src_path="${DEFAULT_SCRIPT_DIR}/raisin"
  fi

  install_env_name_default="raisin_master"
  if install_env_name_existing="$(raisin_extract_env_name "${install_path}" 2>/dev/null)"; then
    install_env_name_default="${install_env_name_existing}"
  fi

  install_env_home="${HOME}/.venvs"
  install_env_name="${install_env_name_default}"
  if [[ -t 0 && -t 1 ]]; then
    install_env_path_default="${install_env_home}/${install_env_name_default}"
    read -r -p "Python ðŸ environment name [${install_env_name_default}] (path: ${install_env_path_default}): " install_env_name
    install_env_name="${install_env_name:-${install_env_name_default}}"
  fi

  if ! raisin_valid_env_name "${install_env_name}"; then
    echo "âŒ Error: invalid environment name: ${install_env_name}" >&2
    echo "Use only letters, numbers, dots, dashes, and underscores." >&2
    exit 1
  fi
  install_env_path="${install_env_home}/${install_env_name}"
  echo "Environment path: ${install_env_path}"

  if ! rm -f "${install_path}"; then
    echo "âŒ Error: cannot overwrite ${install_path}. Check permissions/ownership." >&2
    exit 1
  fi
  if ! cp -f "${src_path}" "${install_path}"; then
    echo "âŒ Error: failed to install wrapper to ${install_path}." >&2
    exit 1
  fi

  if ! raisin_update_env_name "${install_path}" "${install_env_name}"; then
    echo "âŒ Error: failed to update environment name in ${install_path}." >&2
    exit 1
  fi

  chmod +x "${install_path}"
  echo "Installed: ${install_path}"
  echo "Environment name: ${install_env_name}"

  # Create the virtual environment immediately
  echo ""
  echo "ðŸ Creating Python virtual environment..."
  if ! raisin_create_env "${install_env_path}"; then
    echo "âŒ Error: failed to create virtual environment at ${install_env_path}." >&2
    exit 1
  fi
  echo ""
  echo "âœ… Virtual environment created: ${install_env_path}"

  # Install system dependencies (cmake, ninja, etc.)
  echo ""
  echo "ðŸ“¦ Installing system dependencies..."
  sys_deps_script="${SCRIPT_DIR}/install_system_deps.sh"
  if [[ -f "${sys_deps_script}" ]]; then
    if ! sudo bash "${sys_deps_script}"; then
      echo "âš ï¸  Some system dependencies may not have installed correctly."
      echo "   You can re-run: sudo bash ${sys_deps_script}"
    fi
  else
    echo "âš ï¸  System dependencies script not found: ${sys_deps_script}"
  fi

  # Add shell function for auto-activation
  echo ""
  echo "ðŸ”§ Configuring shell for venv auto-activation..."

  # Detect shell config file
  shell_config=""
  if [[ -n "${ZSH_VERSION:-}" ]] || [[ "${SHELL}" == *"zsh"* ]]; then
    shell_config="${HOME}/.zshrc"
  else
    shell_config="${HOME}/.bashrc"
  fi

  # The shell function to add
  shell_function="
# RAISIN: Auto-activate venv when running raisin commands
raisin() {
    if [[ -f \"${install_env_path}/bin/activate\" ]]; then
        source \"${install_env_path}/bin/activate\"
    elif [[ -f \"${install_env_path}/Scripts/activate\" ]]; then
        source \"${install_env_path}/Scripts/activate\"
    fi
    \"${install_path}\" \"\$@\"
}"

  # Check if function already exists
  if [[ -f "${shell_config}" ]] && grep -q "^raisin()" "${shell_config}"; then
    echo "  Shell function already exists in ${shell_config}. To update, please remove it and re-run the installer."
  else
    # Backup and append
    cp "${shell_config}" "${shell_config}.bak" 2>/dev/null || true
    echo "${shell_function}" >> "${shell_config}"
    echo "  âœ… Added raisin() function to ${shell_config}"
  fi

  echo ""
  echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
  echo "â”‚  Installation complete!                                  â”‚"
  echo "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
  echo "â”‚  To activate changes, run:                               â”‚"
  echo "â”‚    source ${shell_config}"
  echo "â”‚                                                          â”‚"
  echo "â”‚  Or restart your terminal.                               â”‚"
  echo "â”‚                                                          â”‚"
  echo "â”‚  Then 'raisin' commands will auto-activate the venv.     â”‚"
  echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
  exit 0
fi

if [[ "${1:-}" == "--where" || "${1:-}" == "--which" ]]; then
  echo "raisin wrapper: ${DEFAULT_SCRIPT_DIR}/raisin"
  echo "selected repo:  ${SCRIPT_DIR}"
  echo "raisin.py:      ${SCRIPT_DIR}/raisin.py"
  echo "config:         ${SCRIPT_DIR}/configuration_setting.yaml"
  exit 0
fi

DEFAULT_ENV_NAME="raisin_master"
DEFAULT_ENV_HOME="${HOME}/.venvs"
DEFAULT_ENV_DIR="${DEFAULT_ENV_HOME}/${DEFAULT_ENV_NAME}"

raisin_prompt_for_python() {
  local choice=""
  local env_input=""
  local resolved=""
  local default_choice="1"

  if [[ -t 0 && -t 1 ]]; then
    echo "No RAISIN Python environment found."
    echo "1) Create default environment (${DEFAULT_ENV_DIR})"
    echo "2) Use existing environment"
    echo "3) Use system Python"
    read -r -p "Select [${default_choice}]: " choice
  else
    choice="${default_choice}"
  fi

  case "${choice:-${default_choice}}" in
    1|"")
      raisin_create_env "${DEFAULT_ENV_DIR}"
      raisin_resolve_python "${DEFAULT_ENV_DIR}"
      return 0
      ;;
    2)
      if [[ ! -t 0 || ! -t 1 ]]; then
        echo "âŒ Error: no TTY available to select an existing environment." >&2
        return 1
      fi
      while true; do
        read -r -p "Path to existing venv dir or python executable: " env_input
        if resolved="$(raisin_resolve_python "${env_input}")"; then
          printf '%s\n' "${resolved}"
          return 0
        fi
        echo "âŒ Not a valid environment or python: ${env_input}" >&2
      done
      ;;
    3)
      resolved="$(raisin_find_bootstrap_python || true)"
      if [[ -z "${resolved}" ]]; then
        echo "âŒ Error: python3 not found. Install Python 3 or set RAISIN_PYTHON." >&2
        return 1
      fi
      printf '%s\n' "${resolved}"
      return 0
      ;;
    *)
      echo "âŒ Invalid choice: ${choice}" >&2
      return 1
      ;;
  esac
}

python_bin="${RAISIN_PYTHON:-}"
if [[ -n "${python_bin}" ]]; then
  if [[ ! -x "${python_bin}" ]]; then
    echo "âŒ Error: RAISIN_PYTHON is not executable: ${python_bin}" >&2
    exit 1
  fi
else
  if python_bin="$(raisin_resolve_python "${DEFAULT_ENV_DIR}")"; then
    :
  elif python_bin="$(raisin_resolve_python "${SCRIPT_DIR}/.venv")"; then
    :
  elif python_bin="$(raisin_resolve_python "${SCRIPT_DIR}/venv")"; then
    :
  else
    if ! python_bin="$(raisin_prompt_for_python)"; then
      exit 1
    fi
  fi
fi

if [[ -z "${python_bin}" ]]; then
  echo "âŒ Error: python3 not found. Install Python 3 or set RAISIN_PYTHON." >&2
  exit 1
fi

# Enable vcpkg binary caching by default to speed builds; users can override via env.
if [[ -z "${VCPKG_BINARY_SOURCES:-}" ]]; then
  vcpkg_cache_root="${SCRIPT_DIR}/.cache/vcpkg-binary"
  mkdir -p "${vcpkg_cache_root}"
  VCPKG_BINARY_SOURCES="files,${vcpkg_cache_root},readwrite"
  export VCPKG_BINARY_SOURCES
fi
if [[ -z "${VCPKG_FEATURE_FLAGS:-}" ]]; then
  VCPKG_FEATURE_FLAGS="manifests,binarycaching"
  export VCPKG_FEATURE_FLAGS
fi

if [[ -z "${RAISIN_VCPKG_PARENT_DIR:-}" ]]; then
  RAISIN_VCPKG_PARENT_DIR="${VCPKG_PARENT_DIR:-${SCRIPT_DIR}/.cache/vcpkg}"
  export RAISIN_VCPKG_PARENT_DIR
fi
mkdir -p "${RAISIN_VCPKG_PARENT_DIR}"

if [[ -z "${RAISIN_VCPKG_INSTALLED_DIR:-}" ]]; then
  RAISIN_VCPKG_INSTALLED_DIR="${VCPKG_INSTALLED_DIR:-${SCRIPT_DIR}/.cache/vcpkg_installed}"
  export RAISIN_VCPKG_INSTALLED_DIR
fi
mkdir -p "${RAISIN_VCPKG_INSTALLED_DIR}"

exec "${python_bin}" "${SCRIPT_DIR}/raisin.py" "$@"
